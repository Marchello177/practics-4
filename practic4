#!/bin/bash
# Функция для вывода справки по использованию скрипта
show_help() {
    echo "  -u, --users       Вывести перечень пользователей и их домашних директорий"
    echo "  -p, --processes   Вывести перечень запущенных процессов"
    echo "  -h, --help        Вывести справку"
    echo "  -l PATH, --log PATH   Перенаправить вывод в файл по заданному пути"
    echo "  -e PATH, --errors PATH Перенаправить вывод ошибок в файл по заданному пути"
} 

# Функция для вывода пользователей и их домашних директорий
list_users() {
    # Если указан файл для логирования, перенаправляем вывод в этот файл
    if [[ -n "$log_file" ]]; then
        exec > "$log_file"
    fi

    # Читаем файл /etc/passwd построчно, извлекаем имя пользователя и домашнюю директорию
    while IFS=: read -r username home_dir; do
        # Проверяем, что имя пользователя и домашняя директория не пустые
        if [[ -n "$username" && -n "$home_dir" ]]; then
            echo "$username $home_dir"  # Выводим имя пользователя и домашнюю директорию
        fi
    done < /etc/passwd | sort  # Сортируем вывод
}

# Функция для вывода запущенных процессов
list_processes() {
    # Если указан файл для логирования, перенаправляем вывод в этот файл
    if [[ -n "$log_file" ]]; then
        exec > "$log_file"
    fi

    # Выводим список всех запущенных процессов с их PID и командой
    ps -e --format pid,cmd --sort pid
}

# Инициализация переменных для хранения путей к файлам логов и ошибок
log_file=""
error_file=""

# Обработка аргументов командной строки с помощью getopts
while getopts ":uphl:e:-:" opt; do
    case $opt in
        u)  # Если указана опция -u, вызываем функцию list_users
            list_users
            exit 0
            ;;
        p)  # Если указана опция -p, вызываем функцию list_processes
            list_processes
            exit 0
            ;;
        h)  # Если указана опция -h, выводим справку
            show_help
            exit 0
            ;;
        l)  # Если указана опция -l, сохраняем путь к файлу лога
            log_file="$OPTARG"
            ;;
        e)  # Если указана опция -e, сохраняем путь к файлу ошибок
            error_file="$OPTARG"
            ;;
        -)  # Обработка длинных опций (например, --users)
            case "${OPTARG}" in
                users)
                    list_users
                    exit 0
                    ;;
                processes)
                    list_processes
                    exit 0
                    ;;
                help)
                    show_help
                    exit 0
                    ;;
                log)
                    log_file="${!OPTIND}"; OPTIND=$((OPTIND + 1))  # Сохраняем путь к файлу лога для длинной опции
                    ;;
                errors)
                    error_file="${!OPTIND}"; OPTIND=$((OPTIND + 1))  # Сохраняем путь к файлу ошибок для длинной опции
                    ;;
                *)
                    echo "Неверный аргумент: --${OPTARG}" >&2  # Обработка неверных аргументов
                    show_help >&2
                    exit 1
                    ;;
            esac
            ;;
        ?) # Обработка неверного однобуквенного аргумента
            echo "Неверный аргумент: -$OPTARG" >&2
            show_help >&2
            exit 1
            ;;
        :)  # Обработка отсутствующего аргумента для однобуквенного аргумента
            echo "Аргумент для -$OPTARG отсутствует." >&2
            show_help >&2
            exit 1
            ;;
    esac
done


if [[ -n "$error_file" ]]; then
    exec 2> "$error_file"  
fi
trap "echo 'Ошибка'>&2" DEBUG  

if [[ -z "$log_file" && -z "$error_file" ]]; then
    show_help
fi
